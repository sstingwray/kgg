{"version":3,"file":"markup-formatters.es.js","sources":["../lib/template.js","../lib/utils.js","../format/html.js","../format/assets/indent-format.js","../format/haml.js","../format/slim.js","../format/pug.js","../index.js"],"sourcesContent":["'use strict';\n\nconst TOKEN       = /^(.*?)([A-Z_]+)(.*?)$/;\nconst TOKEN_OPEN  = 91; // [\nconst TOKEN_CLOSE = 93; // ]\n\n/**\n * A basic templating engine.\n * Takes every `[TOKEN]` from given string and replaces it with\n * `TOKEN` value from given `data` attribute. The token itself may contain\n * various characters between `[`, token name and `]`. Contents of `[...]` will\n * be outputted only if `TOKEN` value is not empty. Also, only `TOKEN` name will\n * be replaced with actual value, all other characters will remain as is.\n *\n * Example:\n * ```\n * template('[<NAME>]', {NAME: 'foo'}) -> \"<foo>\"\n * template('[<NAME>]', {}) -> \"\"\n * ```\n */\nexport default function template(str, data) {\n\tif (str == null) {\n\t\treturn str;\n\t}\n\n\t// NB since token may contain inner `[` and `]`, we can’t just use regexp\n\t// for replacement, should manually parse string instead\n\tconst stack = [];\n\tconst replacer = (str, left, token, right) =>\n\t\tdata[token] != null ? left + data[token] + right : '';\n\n\tlet output = '';\n\tlet offset = 0, i = 0;\n\tlet code, lastPos;\n\n\twhile (i < str.length) {\n\t\tcode = str.charCodeAt(i);\n\t\tif (code === TOKEN_OPEN) {\n\t\t\tstack.push(i);\n\t\t} else if (code === TOKEN_CLOSE) {\n\t\t\tlastPos = stack.pop();\n\t\t\tif (!stack.length) {\n\t\t\t\toutput += str.slice(offset, lastPos) +\n\t\t\t\t\tstr.slice(lastPos + 1, i).replace(TOKEN, replacer);\n\t\t\t\toffset = i + 1;\n\t\t\t}\n\t\t}\n\n\t\ti++;\n\t}\n\n\treturn output + str.slice(offset);\n}\n","'use strict';\n\nimport parseFields from '@emmetio/field-parser';\n\n/**\n * Various utility methods used by formatters\n */\n\n/**\n * Splits given text by lines\n * @param  {String} text\n * @return {String[]}\n */\nexport function splitByLines(text) {\n\treturn (text || '').split(/\\r\\n|\\r|\\n/g);\n}\n\n/**\n * Check if given node is a first child in its parent\n * @param  {Node}  node\n * @return {Boolean}\n */\nexport function isFirstChild(node) {\n\treturn node.parent.firstChild === node;\n}\n\n/**\n * Check if given node is a last child in its parent node\n * @param  {Node}  node\n * @return {Boolean}\n */\nexport function isLastChild(node) {\n\treturn node.parent.lastChild === node;\n}\n\n/**\n * Check if given node is a root node\n * @param  {Node}  node\n * @return {Boolean}\n */\nexport function isRoot(node) {\n\treturn node && !node.parent;\n}\n\n/**\n * Check if given node is a pseudo-snippet: a text-only node with explicitly\n * defined children\n * @param  {Node}  node\n * @return {Boolean}\n */\nexport function isPseudoSnippet(node) {\n\treturn node.isTextOnly && !!node.children.length;\n}\n\n/**\n * Handles pseudo-snippet node.\n * A pseudo-snippet is a text-only node with explicitly defined children.\n * For such case, we have to figure out if pseudo-snippet contains fields\n * (tab-stops) in node value and “split” it: make contents before field with\n * lowest index node’s “open” part and contents after lowest index — “close”\n * part. With this trick a final output will look like node’s children\n * are nested inside node value\n * @param  {OutputNode} outNode\n * @return {Boolean} Returns “true” if given node is a pseudo-snippets,\n * `false` otherwise\n */\nexport function handlePseudoSnippet(outNode) {\n\tconst node = outNode.node; // original abbreviaiton node\n\n\tif (isPseudoSnippet(node)) {\n\t\tconst fieldsModel = parseFields(node.value);\n\t\tconst field = findLowestIndexField(fieldsModel);\n\t\tif (field) {\n\t\t\tconst parts = splitFieldsModel(fieldsModel, field);\n\t\t\toutNode.open = outNode.renderFields(parts[0]);\n\t\t\toutNode.close = outNode.renderFields(parts[1]);\n\t\t} else {\n\t\t\toutNode.text = outNode.renderFields(fieldsModel);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * Finds field with lowest index in given text\n * @param  {Object} model\n * @return {Object}\n */\nexport function findLowestIndexField(model) {\n\treturn model.fields.reduce((result, field) =>\n\t\t!result || field.index < result.index ? field : result\n\t\t, null);\n}\n\n/**\n * Splits given fields model in two parts by given field\n * @param  {Object} model\n * @param  {Object} field\n * @return {Array} Two-items array\n */\nexport function splitFieldsModel(model, field) {\n\tconst ix = model.fields.indexOf(field);\n\n\tconst left = new model.constructor(\n\t\tmodel.string.slice(0, field.location),\n\t\tmodel.fields.slice(0, ix)\n\t);\n\n\tconst right = new model.constructor(\n\t\tmodel.string.slice(field.location + field.length),\n\t\tmodel.fields.slice(ix + 1)\n\t);\n\n\treturn [left, right];\n}\n","'use strict';\n\nimport parseFields from '@emmetio/field-parser';\nimport render from '@emmetio/output-renderer';\nimport template from '../lib/template';\nimport { handlePseudoSnippet, isFirstChild, isRoot, isPseudoSnippet } from '../lib/utils';\n\nconst commentOptions = {\n\t// enable node commenting\n\tenabled: false,\n\n\t// attributes that should trigger node commenting on specific node,\n\t// if commenting is enabled\n\ttrigger: ['id', 'class'],\n\n\t// comment before opening tag\n\tbefore: '',\n\n\t// comment after closing tag\n\tafter: '\\n<!-- /[#ID][.CLASS] -->'\n};\n\n/**\n * Renders given parsed Emmet abbreviation as HTML, formatted according to\n * `profile` options\n * @param  {Node}     tree    Parsed Emmet abbreviation\n * @param  {Profile}  profile Output profile\n * @param  {Object}  [options] Additional formatter options\n * @return {String}\n */\nexport default function html(tree, profile, options) {\n\toptions = Object.assign({}, options);\n\tconst format = getFormatOptions(options);\n\n\treturn render(tree, options.field, outNode => {\n\t\toutNode = setFormatting(outNode, profile);\n\n\t\tif (!handlePseudoSnippet(outNode)) {\n\t\t\tconst node = outNode.node;\n\n\t\t\tif (node.name) {\n\t\t\t\tconst name = profile.name(node.name);\n\t\t\t\tconst attrs = formatAttributes(outNode, profile);\n\n\t\t\t\toutNode.open = `<${name}${attrs}${node.selfClosing ? profile.selfClose() : ''}>`;\n\t\t\t\tif (!node.selfClosing) {\n\t\t\t\t\toutNode.close = `</${name}>`;\n\t\t\t\t}\n\n\t\t\t\tcommentNode(outNode, format.comment);\n\t\t\t}\n\n\t\t\t// Do not generate fields for nodes with empty value and children\n\t\t\t// or if node is self-closed\n\t\t\tif (node.value || (!node.children.length && !node.selfClosing) ) {\n\t\t\t\toutNode.text = outNode.renderFields(node.value);\n\t\t\t}\n\t\t}\n\n\t\treturn outNode;\n\t});\n}\n\n/**\n * Updates formatting properties for given output node\n * @param  {OutputNode} outNode Output wrapper of farsed abbreviation node\n * @param  {Profile}    profile Output profile\n * @return {OutputNode}\n */\nfunction setFormatting(outNode, profile) {\n\tconst node = outNode.node;\n\n\tif (shouldFormatNode(node, profile)) {\n\t\toutNode.indent = profile.indent(getIndentLevel(node, profile));\n\t\toutNode.newline = '\\n';\n\t\tconst prefix = outNode.newline + outNode.indent;\n\n\t\t// do not format the very first node in output\n\t\tif (!isRoot(node.parent) || !isFirstChild(node)) {\n\t\t\toutNode.beforeOpen = prefix;\n\t\t\tif (node.isTextOnly) {\n\t\t\t\toutNode.beforeText = prefix;\n\t\t\t}\n\t\t}\n\n\t\tif (hasInnerFormatting(node, profile)) {\n\t\t\tif (!node.isTextOnly) {\n\t\t\t\toutNode.beforeText = prefix + profile.indent(1);\n\t\t\t}\n\t\t\toutNode.beforeClose = prefix;\n\t\t}\n\t}\n\n\treturn outNode;\n}\n\n/**\n * Check if given node should be formatted\n * @param  {Node} node\n * @param  {Profile} profile\n * @return {Boolean}\n */\nfunction shouldFormatNode(node, profile) {\n\tif (!profile.get('format')) {\n\t\treturn false;\n\t}\n\n\tif (node.parent.isTextOnly\n\t\t&& node.parent.children.length === 1\n\t\t&& parseFields(node.parent.value).fields.length) {\n\t\t// Edge case: do not format the only child of text-only node,\n\t\t// but only if parent contains fields\n\t\treturn false;\n\t}\n\n\treturn isInline(node, profile) ? shouldFormatInline(node, profile) : true;\n}\n\n/**\n * Check if given inline node should be formatted as well, e.g. it contains\n * enough adjacent siblings that should force formatting\n * @param  {Node} node\n * @param  {Profile} profile\n * @return {Boolean}\n */\nfunction shouldFormatInline(node, profile) {\n\tif (!isInline(node, profile)) {\n\t\treturn false;\n\t}\n\n\tif (isPseudoSnippet(node)) {\n\t\treturn true;\n\t}\n\n\t// check if inline node is the next sibling of block-level node\n\tif (node.childIndex === 0) {\n\t\t// first node in parent: format if it’s followed by a block-level element\n\t\tlet next = node;\n\t\twhile (next = next.nextSibling) {\n\t\t\tif (!isInline(next, profile)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t} else if (!isInline(node.previousSibling, profile)) {\n\t\t// node is right after block-level element\n\t\treturn true;\n\t}\n\n\tif (profile.get('inlineBreak')) {\n\t\t// check for adjacent inline elements before and after current element\n\t\tlet adjacentInline = 1;\n\t\tlet before = node, after = node;\n\n\t\twhile (isInlineElement((before = before.previousSibling), profile)) {\n\t\t\tadjacentInline++;\n\t\t}\n\n\t\twhile (isInlineElement((after = after.nextSibling), profile)) {\n\t\t\tadjacentInline++;\n\t\t}\n\n\t\tif (adjacentInline >= profile.get('inlineBreak')) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// Another edge case: inline node contains node that should receive foramtting\n\tfor (let i = 0, il = node.children.length; i < il; i++) {\n\t\tif (shouldFormatNode(node.children[i], profile)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * Check if given node contains inner formatting, e.g. any of its children should\n * be formatted\n * @param  {Node} node\n * @param  {Profile} profile\n * @return {Boolean}\n */\nfunction hasInnerFormatting(node, profile) {\n\t// check if node if forced for inner formatting\n\tconst nodeName = (node.name || '').toLowerCase();\n\tif (profile.get('formatForce').indexOf(nodeName) !== -1) {\n\t\treturn true;\n\t}\n\n\t// check if any of children should receive formatting\n\t// NB don’t use `childrent.some()` to reduce memory allocations\n\tfor (let i = 0; i < node.children.length; i++) {\n\t\tif (shouldFormatNode(node.children[i], profile)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * Outputs attributes of given abbreviation node as HTML attributes\n * @param  {OutputNode} outNode\n * @param  {Profile}    profile\n * @return {String}\n */\nfunction formatAttributes(outNode, profile) {\n\tconst node = outNode.node;\n\n\treturn node.attributes.map(attr => {\n\t\tif (attr.options.implied && attr.value == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst attrName = profile.attribute(attr.name);\n\t\tlet attrValue = null;\n\n\t\t// handle boolean attributes\n\t\tif (attr.options.boolean || profile.get('booleanAttributes').indexOf(attrName.toLowerCase()) !== -1) {\n\t\t\tif (profile.get('compactBooleanAttributes') && attr.value == null) {\n\t\t\t\treturn ` ${attrName}`;\n\t\t\t} else if (attr.value == null) {\n\t\t\t\tattrValue = attrName;\n\t\t\t}\n\t\t}\n\n\t\tif (attrValue == null) {\n\t\t\tattrValue = outNode.renderFields(attr.value);\n\t\t}\n\n\t\treturn attr.options.before && attr.options.after\n\t\t\t? ` ${attrName}=${attr.options.before+attrValue+attr.options.after}`\n\t\t\t: ` ${attrName}=${profile.quote(attrValue)}`;\n\t}).join('');\n}\n\n/**\n * Check if given node is inline-level\n * @param  {Node}  node\n * @param  {Profile}  profile\n * @return {Boolean}\n */\nfunction isInline(node, profile) {\n\treturn (node && node.isTextOnly) || isInlineElement(node, profile);\n}\n\n/**\n * Check if given node is inline-level element, e.g. element with explicitly\n * defined node name\n * @param  {Node}  node\n * @param  {Profile}  profile\n * @return {Boolean}\n */\nfunction isInlineElement(node, profile) {\n\treturn node && profile.isInline(node);\n}\n\n/**\n * Computes indent level for given node\n * @param  {Node} node\n * @param  {Profile} profile\n * @param  {Number} level\n * @return {Number}\n */\nfunction getIndentLevel(node, profile) {\n\t// Increase indent level IF NOT:\n\t// * parent is text-only node\n\t// * there’s a parent node with a name that is explicitly set to decrease level\n\tconst skip = profile.get('formatSkip') || [];\n\tlet level = node.parent.isTextOnly ? -2 : -1;\n\tlet ctx = node;\n\twhile (ctx = ctx.parent) {\n\t\tif (skip.indexOf( (ctx.name || '').toLowerCase() ) === -1) {\n\t\t\tlevel++;\n\t\t}\n\t}\n\n\treturn level < 0 ? 0 : level;\n}\n\n/**\n * Comments given output node, if required\n * @param  {OutputNode} outNode\n * @param  {Object} options\n */\nfunction commentNode(outNode, options) {\n\tconst node = outNode.node;\n\n\tif (!options.enabled || !options.trigger || !node.name) {\n\t\treturn;\n\t}\n\n\tconst attrs = outNode.node.attributes.reduce((out, attr) => {\n\t\tif (attr.name && attr.value != null) {\n\t\t\tout[attr.name.toUpperCase().replace(/-/g, '_')] = attr.value;\n\t\t}\n\n\t\treturn out;\n\t}, {});\n\n\t// add comment only if attribute trigger is present\n\tfor (let i = 0, il = options.trigger.length; i < il; i++) {\n\t\tif (options.trigger[i].toUpperCase() in attrs) {\n\t\t\toutNode.open = template(options.before, attrs) + outNode.open;\n\t\t\tif (outNode.close) {\n\t\t\t\toutNode.close += template(options.after, attrs);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nfunction getFormatOptions(options) {\n\tconst format = Object.assign({}, options && options.format);\n\tformat.comment = Object.assign({}, commentOptions, format.comment);\n\treturn format;\n}\n","'use strict';\n\n/**\n * Common utility methods for indent-based syntaxes (Slim, Pug, etc.)\n */\n\nimport template from '../../lib/template';\nimport { isFirstChild, isRoot } from '../../lib/utils';\n\nconst reId = /^id$/i;\nconst reClass = /^class$/i;\nconst defaultAttrOptions = {\n\tprimary: attrs => attrs.join(''),\n\tsecondary: attrs => attrs.map(attr => attr.isBoolean ? attr.name : `${attr.name}=${attr.value}`).join(', ')\n};\n\nconst defaultNodeOptions = {\n\topen: null,\n\tclose: null,\n\tomitName: /^div$/i,\n\tattributes: defaultAttrOptions\n};\n\nexport default function indentFormat(outNode, profile, options) {\n\toptions = Object.assign({}, defaultNodeOptions, options);\n\tconst node = outNode.node;\n\n\toutNode.indent = profile.indent(getIndentLevel(node, profile));\n\toutNode.newline = '\\n';\n\n\t// Do not format the very first node in output\n\tif (!isRoot(node.parent) || !isFirstChild(node)) {\n\t\toutNode.beforeOpen = outNode.newline + outNode.indent;\n\t}\n\n\tif (node.name) {\n\t\tconst data = Object.assign({\n\t\t\tNAME: profile.name(node.name),\n\t\t\tSELF_CLOSE: node.selfClosing ? options.selfClose : null\n\t\t}, getAttributes(outNode, profile, options.attributes));\n\n\t\t// omit tag name if node has primary attributes\n\t\tif (options.omitName && options.omitName.test(data.NAME) && data.PRIMARY_ATTRS) {\n\t\t\tdata.NAME = null;\n\t\t}\n\n\t\tif (options.open != null) {\n\t\t\toutNode.open = template(options.open, data);\n\t\t}\n\n\t\tif (options.close != null) {\n\t\t\toutNode.close = template(options.close, data);\n\t\t}\n\t}\n\n\treturn outNode;\n}\n\n/**\n * Formats attributes of given node into a string.\n * @param  {OutputNode} node          Output node wrapper\n * @param  {Profile}    profile       Output profile\n * @param  {Object}     options       Additional formatting options\n * @return {String}\n */\nexport function getAttributes(outNode, profile, options) {\n\toptions = Object.assign({}, defaultAttrOptions, options);\n\tconst primary = [], secondary = [];\n\tconst node = outNode.node;\n\n\tnode.attributes.forEach(attr => {\n\t\tif (attr.options.implied && attr.value == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst name = profile.attribute(attr.name);\n\t\tconst value = outNode.renderFields(attr.value);\n\n\t\tif (reId.test(name)) {\n\t\t\tvalue && primary.push(`#${value}`);\n\t\t} else if (reClass.test(name)) {\n\t\t\tvalue && primary.push(`.${value.replace(/\\s+/g, '.')}`);\n\t\t} else {\n\t\t\tconst isBoolean = attr.value == null\n\t\t\t\t&& (attr.options.boolean || profile.get('booleanAttributes').indexOf(name.toLowerCase()) !== -1);\n\n\t\t\tsecondary.push({ name, value, isBoolean });\n\t\t}\n\t});\n\n\treturn {\n\t\tPRIMARY_ATTRS: options.primary(primary) || null,\n\t\tSECONDARY_ATTRS: options.secondary(secondary) || null\n\t};\n}\n\n/**\n * Computes indent level for given node\n * @param  {Node} node\n * @return {Number}\n */\nexport function getIndentLevel(node) {\n\tlet level = node.parent.isTextOnly ? -2 : -1;\n\tlet ctx = node;\n\twhile (ctx = ctx.parent) {\n\t\tlevel++;\n\t}\n\n\treturn level < 0 ? 0 : level;\n}\n","'use strict';\n\nimport render from '@emmetio/output-renderer';\nimport indentFormat from './assets/indent-format';\nimport { splitByLines, handlePseudoSnippet } from '../lib/utils';\n\nconst reNl = /\\n|\\r/;\n\n/**\n * Renders given parsed Emmet abbreviation as HAML, formatted according to\n * `profile` options\n * @param  {Node}    tree      Parsed Emmet abbreviation\n * @param  {Profile} profile   Output profile\n * @param  {Object}  [options] Additional formatter options\n * @return {String}\n */\nexport default function haml(tree, profile, options) {\n\toptions = options || {};\n\tconst nodeOptions = {\n\t\topen: '[%NAME][PRIMARY_ATTRS][(SECONDARY_ATTRS)][SELF_CLOSE]',\n\t\tselfClose: '/',\n\t\tattributes: {\n\t\t\tsecondary(attrs) {\n\t\t\t\treturn attrs.map(attr => attr.isBoolean\n\t\t\t\t\t? `${attr.name}${profile.get('compactBooleanAttributes') ? '' : '=true'}`\n\t\t\t\t\t: `${attr.name}=${profile.quote(attr.value)}`\n\t\t\t\t).join(' ');\n\t\t\t}\n\t\t}\n\t};\n\n\treturn render(tree, options.field, outNode => {\n\t\toutNode = indentFormat(outNode, profile, nodeOptions);\n\t\toutNode = updateFormatting(outNode, profile);\n\n\t\tif (!handlePseudoSnippet(outNode)) {\n\t\t\tconst node = outNode.node;\n\n\t\t\t// Do not generate fields for nodes with empty value and children\n\t\t\t// or if node is self-closed\n\t\t\tif (node.value || (!node.children.length && !node.selfClosing) ) {\n\t\t\t\toutNode.text = outNode.renderFields(formatNodeValue(node, profile));\n\t\t\t}\n\t\t}\n\n\t\treturn outNode;\n\t});\n}\n\n/**\n * Updates formatting properties for given output node\n * NB Unlike HTML, HAML is indent-based format so some formatting options from\n * `profile` will not take effect, otherwise output will be broken\n * @param  {OutputNode} outNode Output wrapper of parsed abbreviation node\n * @param  {Profile}    profile Output profile\n * @return {OutputNode}\n */\nfunction updateFormatting(outNode, profile) {\n\tconst node = outNode.node;\n\n\tif (!node.isTextOnly && node.value) {\n\t\t// node with text: put a space before single-line text\n\t\toutNode.beforeText = reNl.test(node.value)\n\t\t\t? outNode.newline + outNode.indent + profile.indent(1)\n\t\t\t: ' ';\n\t}\n\n\treturn outNode;\n}\n/**\n * Formats value of given node: for multiline text we should add a ` |` suffix\n * at the end of each line. Also ensure that text is perfectly aligned.\n * @param  {Node}    node\n * @param  {Profile} profile\n * @return {String|null}\n */\nfunction formatNodeValue(node, profile) {\n\tif (node.value != null && reNl.test(node.value)) {\n\t\tconst lines = splitByLines(node.value);\n\t\tconst indent = profile.indent(1);\n\t\tconst maxLength = lines.reduce((prev, line) => Math.max(prev, line.length), 0);\n\n\t\treturn lines.map((line, i) => `${i ? indent : ''}${pad(line, maxLength)} |`).join('\\n');\n\t}\n\n\treturn node.value;\n}\n\nfunction pad(text, len) {\n\twhile (text.length < len) {\n\t\ttext += ' ';\n\t}\n\n\treturn text;\n}\n","'use strict';\n\nimport render from '@emmetio/output-renderer';\nimport indentFormat from './assets/indent-format';\nimport { splitByLines, handlePseudoSnippet, isRoot } from '../lib/utils';\n\nconst reNl = /\\n|\\r/;\nconst secondaryAttrs = {\n\tnone:   '[ SECONDARY_ATTRS]',\n\tround:  '[(SECONDARY_ATTRS)]',\n\tcurly:  '[{SECONDARY_ATTRS}]',\n\tsquare: '[[SECONDARY_ATTRS]'\n};\n\n/**\n * Renders given parsed Emmet abbreviation as Slim, formatted according to\n * `profile` options\n * @param  {Node}    tree      Parsed Emmet abbreviation\n * @param  {Profile} profile   Output profile\n * @param  {Object}  [options] Additional formatter options\n * @return {String}\n */\nexport default function slim(tree, profile, options) {\n\toptions = options || {};\n\tconst SECONDARY_ATTRS = options.attributeWrap\n\t\t&& secondaryAttrs[options.attributeWrap]\n\t\t|| secondaryAttrs.none;\n\n\tconst booleanAttr = SECONDARY_ATTRS === secondaryAttrs.none\n\t\t? attr => `${attr.name}=true`\n\t\t: attr => attr.name;\n\n\tconst nodeOptions = {\n\t\topen: `[NAME][PRIMARY_ATTRS]${SECONDARY_ATTRS}[SELF_CLOSE]`,\n\t\tselfClose: '/',\n\t\tattributes: {\n\t\t\tsecondary(attrs) {\n\t\t\t\treturn attrs.map(attr => attr.isBoolean\n\t\t\t\t\t? booleanAttr(attr)\n\t\t\t\t\t: `${attr.name}=${profile.quote(attr.value)}`\n\t\t\t\t).join(' ');\n\t\t\t}\n\t\t}\n\t};\n\n\treturn render(tree, options.field, outNode => {\n\t\toutNode = indentFormat(outNode, profile, nodeOptions);\n\t\toutNode = updateFormatting(outNode, profile);\n\n\t\tif (!handlePseudoSnippet(outNode)) {\n\t\t\tconst node = outNode.node;\n\n\t\t\t// Do not generate fields for nodes with empty value and children\n\t\t\t// or if node is self-closed\n\t\t\tif (node.value || (!node.children.length && !node.selfClosing) ) {\n\t\t\t\toutNode.text = outNode.renderFields(formatNodeValue(node, profile));\n\t\t\t}\n\t\t}\n\n\t\treturn outNode;\n\t});\n}\n\n/**\n * Updates formatting properties for given output node\n * NB Unlike HTML, Slim is indent-based format so some formatting options from\n * `profile` will not take effect, otherwise output will be broken\n * @param  {OutputNode} outNode Output wrapper of farsed abbreviation node\n * @param  {Profile}    profile Output profile\n * @return {OutputNode}\n */\nfunction updateFormatting(outNode, profile) {\n\tconst node = outNode.node;\n\tconst parent = node.parent;\n\n\t// Edge case: a single inline-level child inside node without text:\n\t// allow it to be inlined\n\tif (profile.get('inlineBreak') === 0 && isInline(node, profile)\n\t\t&& !isRoot(parent) && parent.value == null && parent.children.length === 1) {\n\t\toutNode.beforeOpen = ': ';\n\t}\n\n\tif (!node.isTextOnly && node.value) {\n\t\t// node with text: put a space before single-line text\n\t\toutNode.beforeText = reNl.test(node.value)\n\t\t\t? outNode.newline + outNode.indent + profile.indent(1)\n\t\t\t: ' ';\n\t}\n\n\treturn outNode;\n}\n\n/**\n * Formats value of given node: for multiline text we should precede each\n * line with `| ` with one-level deep indent\n * @param  {Node} node\n * @param  {Profile} profile\n * @return {String|null}\n */\nfunction formatNodeValue(node, profile) {\n\tif (node.value != null && reNl.test(node.value)) {\n\t\tconst indent = profile.indent(1);\n\t\treturn splitByLines(node.value).map((line, i) => `${indent}${i ? ' ' : '|'} ${line}`).join('\\n');\n\t}\n\n\treturn node.value;\n}\n\n/**\n * Check if given node is inline-level\n * @param  {Node}  node\n * @param  {Profile}  profile\n * @return {Boolean}\n */\nfunction isInline(node, profile) {\n\treturn node && (node.isTextOnly || profile.isInline(node));\n}\n","'use strict';\n\nimport render from '@emmetio/output-renderer';\nimport indentFormat from './assets/indent-format';\nimport { splitByLines, handlePseudoSnippet } from '../lib/utils';\n\nconst reNl = /\\n|\\r/;\n\n/**\n * Renders given parsed Emmet abbreviation as Pug, formatted according to\n * `profile` options\n * @param  {Node}    tree      Parsed Emmet abbreviation\n * @param  {Profile} profile   Output profile\n * @param  {Object}  [options] Additional formatter options\n * @return {String}\n */\nexport default function pug(tree, profile, options) {\n\toptions = options || {};\n\tconst nodeOptions = {\n\t\topen: '[NAME][PRIMARY_ATTRS][(SECONDARY_ATTRS)]',\n\t\tattributes: {\n\t\t\tsecondary(attrs) {\n\t\t\t\treturn attrs.map(attr => attr.isBoolean ? attr.name : `${attr.name}=${profile.quote(attr.value)}`).join(', ');\n\t\t\t}\n\t\t}\n\t};\n\n\treturn render(tree, options.field, outNode => {\n\t\toutNode = indentFormat(outNode, profile, nodeOptions);\n\t\toutNode = updateFormatting(outNode, profile);\n\n\t\tif (!handlePseudoSnippet(outNode)) {\n\t\t\tconst node = outNode.node;\n\t\t\t// Do not generate fields for nodes with empty value and children\n\t\t\t// or if node is self-closed\n\t\t\tif (node.value || (!node.children.length && !node.selfClosing) ) {\n\t\t\t\toutNode.text = outNode.renderFields(formatNodeValue(node, profile));\n\t\t\t}\n\t\t}\n\n\t\treturn outNode;\n\t});\n}\n\n/**\n * Updates formatting properties for given output node\n * NB Unlike HTML, Pug is indent-based format so some formatting options from\n * `profile` will not take effect, otherwise output will be broken\n * @param  {OutputNode} outNode Output wrapper of parsed abbreviation node\n * @param  {Profile}    profile Output profile\n * @return {OutputNode}\n */\nfunction updateFormatting(outNode, profile) {\n\tconst node = outNode.node;\n\n\tif (!node.isTextOnly && node.value) {\n\t\t// node with text: put a space before single-line text\n\t\toutNode.beforeText = reNl.test(node.value)\n\t\t\t? outNode.newline + outNode.indent + profile.indent(1)\n\t\t\t: ' ';\n\t}\n\n\treturn outNode;\n}\n\n/**\n * Formats value of given node: for multiline text we should precede each\n * line with `| ` with one-level deep indent\n * @param  {Node} node\n * @param  {Profile} profile\n * @return {String|null}\n */\nfunction formatNodeValue(node, profile) {\n\tif (node.value != null && reNl.test(node.value)) {\n\t\tconst indent = profile.indent(1);\n\t\treturn splitByLines(node.value).map(line => `${indent}| ${line}`).join('\\n');\n\t}\n\n\treturn node.value;\n}\n","'use strict';\n\nimport html from './format/html';\nimport haml from './format/haml';\nimport slim from './format/slim';\nimport pug  from './format/pug';\nimport template  from './lib/template';\n\nconst supportedSyntaxes = { html, haml, slim, pug };\n\n/**\n * Outputs given parsed abbreviation in specified syntax\n * @param {Node}     tree     Parsed abbreviation tree\n * @param {Profile}  profile  Output profile\n * @param {String}   [syntax] Output syntax. If not given, `html` syntax is used\n * @param {Function} options.field A function to output field/tabstop for\n * host editor. This function takes two arguments: `index` and `placeholder` and\n * should return a string that represents tabstop in host editor. By default\n * only a placeholder is returned\n * @example\n * {\n * \tfield(index, placeholder) {\n * \t\t// return field in TextMate-style, e.g. ${1} or ${2:foo}\n * \t\treturn `\\${${index}${placeholder ? ':' + placeholder : ''}}`;\n *  }\n * }\n * @return {String}\n */\nexport default function(tree, profile, syntax, options) {\n\tif (typeof syntax === 'object') {\n\t\toptions = syntax;\n\t\tsyntax = null;\n\t}\n\n\tif (!supports(syntax)) {\n\t\t// fallback to HTML if given syntax is not supported\n\t\tsyntax = 'html';\n\t}\n\n\treturn supportedSyntaxes[syntax](tree, profile, options);\n}\n\n/**\n * Check if given syntax is supported\n * @param {String} syntax\n * @return {Boolean}\n */\nexport function supports(syntax) {\n\treturn !!syntax && syntax in supportedSyntaxes;\n}\n\nexport { template };\n"],"names":["getIndentLevel","reNl","updateFormatting","formatNodeValue","isInline"],"mappings":"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"}